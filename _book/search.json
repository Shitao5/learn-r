[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn-R",
    "section": "",
    "text": "License\n\n本书作为整体在知识共享署名-非商业性-相同方式共享4.0国际许可证下授权。\n本书包含的代码在MIT 许可证下提供；这意味着你可以在引用来源的情况下自由使用。\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. O’Reilly Media."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "本书内容包括数据可视化、金融。"
  },
  {
    "objectID": "Visualisation.html",
    "href": "Visualisation.html",
    "title": "Visualisation",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "vis-ggplot2.html",
    "href": "vis-ggplot2.html",
    "title": "\n1  ggplot2\n",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节正在进行写作和结构调整，可能出现混乱或不完整的情况。\nggplot2(Wickham 2016)具有底层的图形语法，ggplot2: Elegant Graphics for Data Analysis重点解释了这套语法， 本章节为其学习笔记。"
  },
  {
    "objectID": "vis-ggplot2.html#ggplot2初步",
    "href": "vis-ggplot2.html#ggplot2初步",
    "title": "\n1  ggplot2\n",
    "section": "\n1.1 ggplot2初步",
    "text": "1.1 ggplot2初步\nggplot2具有颜色（color）、大小（size）、形状（shape）、填充（fill）等美学属性，适用于不同类型的图形。\n在绘图美学中，少即是多，使用美学映射需要节制。与其用一幅非常复杂的图形一次展示所有，不如创造一些简单的情节，讲述一个故事，让读者的认识从无到有。"
  },
  {
    "objectID": "vis-ggplot2.html#图层layers",
    "href": "vis-ggplot2.html#图层layers",
    "title": "\n1  ggplot2\n",
    "section": "\n1.2 图层（Layers）",
    "text": "1.2 图层（Layers）\nggplot2的分层结构1使得我们可以以结构化的方式设计和构建图形。一般来说，图层有三个功能：\n\n展示数据\n展示数据的统计摘要\n添加额外的元数据：背景、注释和参考文献。\n\n\n1.2.1 基本图形\n\ndf <- data.frame(\n  x = c(3, 1, 5),\n  y = c(2, 4, 6),\n  label = c(\"a\", \"b\", \"c\")\n)\n\np <- ggplot(df, aes(x, y, label = label)) +\n  labs(x = NULL, y = NULL) +\n  theme(plot.title = element_text(size = 12))\n\np + geom_point() + ggtitle(\"point\")\np + geom_text() + ggtitle(\"text\")\np + geom_bar(stat = \"identity\") + ggtitle(\"bar\")\np + geom_tile() + ggtitle(\"raster\")\n\np + geom_line() + ggtitle(\"line\")\np + geom_area() + ggtitle(\"area\")\np + geom_path() + ggtitle(\"path\")\np + geom_polygon() + ggtitle(\"polygon\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.2 揭示不确定性\n根据x轴是否连续和是否展示中间值，比较基本的有：\n\ndf <- data.frame(x = 1:3,\n                 y = c(18, 11, 16),\n                 se = c(1.2, .5, 1.0))\n\nbase <- ggplot(df, aes(x, y,\n                       ymin = y - se,\n                       ymax = y + se))\nbase + geom_crossbar()\nbase + geom_pointrange()\nbase + geom_smooth(stat = \"identity\")\n\nbase + geom_errorbar()\nbase + geom_linerange()\nbase + geom_ribbon()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.3 权重数据\n汇总数据的每一行代表多个观测值，因此需要考虑权重变量。权重变量的选择将影响绘图和得出的结论。\n对于点图、线图等简单图形，使用大小（size)美学。\n\n# Unweighted\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point()\n\n# Weighted by population\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point(aes(size = poptotal / 1e6)) +\n  scale_size_area(\"Population\\n(millions)\",\n                  breaks = c(.5, 1, 2, 4))\n\n\n\n\n\n\n\n\n\n\n\n对于涉及统计转换等复杂图形，使用weight美学指定权重。权重支持平滑、量化回归、箱型图、直方图、密度图等情形。我们无法直接从图中看出权重变量，它也不会产生图例，但会改变统计汇总的结果。\n\n# Unweighted\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point() +\n  geom_smooth(method = lm, size = 1)\n\n# Weighted by population\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point(aes(size = poptotal / 1e6)) +\n  geom_smooth(aes(weight = poptotal), method = lm, size = 1) +\n  scale_size_area(guide = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.4 地图\n绘制地理空间数据是一项常见的可视化任务，它需要专门的工作。通常来讲，可以把任务分成两步：\n\n使用数据源绘制地图；\n从信息源添加元数据到地图上。\n\nR语言内置了地图包，虽然不是最新的，但是一个好的起点。这里从中提取密歇根州的县界：\n\nlibrary(tidyverse) # 用于数据处理\nmi_counties <- map_data(\"county\", \"michigan\") %>% \n  select(lon = long, lat, group, id = subregion)\nhead(mi_counties)\n#>     lon  lat group     id\n#> 1 -83.9 44.9     1 alcona\n#> 2 -83.4 44.9     1 alcona\n#> 3 -83.4 44.9     1 alcona\n#> 4 -83.3 44.8     1 alcona\n#> 5 -83.3 44.8     1 alcona\n#> 6 -83.3 44.8     1 alcona\n\n利用散点图可以看到数据集中每个县的角落，通过geom_polygon()将散点图绘制成地图：\n\nggplot(mi_counties, aes(lon, lat)) +\n  geom_point(size = .25, show.legend = FALSE) +\n  coord_quickmap()\n\nggplot(mi_counties, aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"grey50\") +\n  coord_quickmap()\n\n\n\n\n\n\n\n\n\n\n\ncoord_quickmap()调整坐标轴，以确保经度和纬度在同一比例上呈现。但地理空间数据往往需要更精准的方法，因此ggplot2提供了geom_sf()和coord_sf()来处理简单特征格式的空间数据。\nSimple feature maps\n上述方法具有局限性，最典型的是：现实世界的地图不是简单地按照”经度-纬度”的数据格式绘制的。 地图的矢量数据通常使用由开放地理空间联盟制定的”简单特征”（simple features）标准进行编码。 sf包(Pebesma 2018)为处理这类数据提供了优质的工具集，ggplot2中的geom_sf()和coord_sf()函数就是为与sf包一起工作而设计的。\n\nlibrary(ozmaps) # 提供澳大利亚的地图数据\nlibrary(sf)\n#> Linking to GEOS 3.9.1, GDAL 3.4.3, PROJ 7.2.1; sf_use_s2() is TRUE\n\nozmap_states\n#> Simple feature collection with 9 features and 1 field\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 106 ymin: -43.6 xmax: 168 ymax: -9.23\n#> Geodetic CRS:  GDA94\n#> # A tibble: 9 × 2\n#>   NAME                                                      geometry\n#> * <chr>                                           <MULTIPOLYGON [°]>\n#> 1 New South Wales              (((151 -35.1, 151 -35.1, 151 -35.1, …\n#> 2 Victoria                     (((147 -38.7, 147 -38.7, 147 -38.7, …\n#> 3 Queensland                   (((149 -20.3, 149 -20.4, 149 -20.4, …\n#> 4 South Australia              (((137 -34.5, 137 -34.5, 137 -34.5, …\n#> 5 Western Australia            (((126 -14, 126 -14, 126 -14, 126 -1…\n#> 6 Tasmania                     (((148 -40.3, 148 -40.3, 148 -40.3, …\n#> 7 Northern Territory           (((136 -13.8, 136 -13.8, 136 -13.8, …\n#> 8 Australian Capital Territory (((149 -35.2, 149 -35.2, 149 -35.3, …\n#> 9 Other Territories            (((168 -29.1, 168 -29, 168 -29, 168 …\n\nsf数据的一个优势，在于我们可以直观地看到数据的整体结构。澳大利亚由6个州和一些地区组成，共9个地理单元，因此数据中有9行。geometry列的每个元素都是一个多边形对象，指定一个或多个多边形顶点，标示着一个地区的边界。\n对于这种格式的数据，我们可以使用geom_sf()和coord_sf()绘制一张可用的地图而不需要制定任何参数，甚至不需要明确美学。\n\nggplot(ozmap_states) +\n  geom_sf() +\n  coord_sf()\n\n\n\n\n\n\n\ngeom_sf()使用ggplot2中其他地方没有使用的geometry美学，这种美学可以通过以下三种方式之一来制定。\n\n用户无需任何操作，geom_sf()自动将名为geometry的列映射到地图中。\n如果数据是一个sf对象，geom_sf()自动检测geometry格式的列，即使该列名不为geometry。\n使用aes(geometry = my_column)手动指定映射，在数据中有多个geometry格式的列时很有用。\n\nggplot2支持多层geom_sf()叠加。使用rmapshaper包(Teucher and Russell 2022)简化边界，以减少渲染绘图的时间。当原始数据集（本例中为abs_ced）的存储分辨率高于绘图要求时，这通常是个好主意。\n\noz_states <- ozmap_states %>% filter(NAME != \"Other Territories\")\noz_votes <- rmapshaper::ms_simplify(abs_ced)\n#> Registered S3 method overwritten by 'geojsonlint':\n#>   method         from \n#>   print.location dplyr\n\nggplot() +\n  geom_sf(data = oz_states, mapping = aes(fill = NAME), show.legend = FALSE) +\n  geom_sf(data = oz_votes, fill = NA) +\n  coord_sf()\n\n\n\n\n\n\n\n图上添加标签：\n\nsydney_map <- abs_ced %>% filter(NAME %in% c(\n  \"Sydney\", \"Wentworth\", \"Warringah\", \"Kingsford Smith\", \"Grayndler\", \"Lowe\", \n  \"North Sydney\", \"Barton\", \"Bradfield\", \"Banks\", \"Blaxland\", \"Reid\", \n  \"Watson\", \"Fowler\", \"Werriwa\", \"Prospect\", \"Parramatta\", \"Bennelong\", \n  \"Mackellar\", \"Greenway\", \"Mitchell\", \"Chifley\", \"McMahon\"\n))\n\nggplot(sydney_map) +\n  geom_sf(aes(fill = NAME), show.legend = FALSE) +\n  coord_sf(xlim = c(150.97, 151.3), ylim = c(-33.98, -33.79)) +\n  geom_sf_label(aes(label = NAME), label.padding = unit(1, \"mm\"))\n#> Warning in st_point_on_surface.sfc(sf::st_zm(x)):\n#> st_point_on_surface may not give correct results for\n#> longitude/latitude data\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\ngeom_sf_label()函数内部使用sf包中的函数st_point_on_surface()来放置标签，出现上述警告是因为sf用于计算几何量（例如中心点、内部点）的大多数算法都是基于这样一个假设：点位于一个平坦的二维表面上，并以笛卡尔坐标作为参数。这种假设并不严格，在某些情况下（例如，靠近两极的地区），以这种方式处理经度和纬度的计算会得到错误的答案。因此，sf软件包在依赖这种近似方式进行计算时将产生警告。\n\n\n添加其他图层：\n\noz_capitals <- tibble::tribble( \n  ~city,           ~lat,     ~lon,\n  \"Sydney\",    -33.8688, 151.2093,  \n  \"Melbourne\", -37.8136, 144.9631, \n  \"Brisbane\",  -27.4698, 153.0251, \n  \"Adelaide\",  -34.9285, 138.6007, \n  \"Perth\",     -31.9505, 115.8605, \n  \"Hobart\",    -42.8821, 147.3272, \n  \"Canberra\",  -35.2809, 149.1300, \n  \"Darwin\",    -12.4634, 130.8456, \n)\n\nggplot() + \n  geom_sf(data = oz_votes) + \n  geom_sf(data = oz_states, colour = \"black\", fill = NA) + \n  geom_point(data = oz_capitals, mapping = aes(x = lon, y = lat), colour = \"red\") + \n  coord_sf()\n\n\n\n\n\n\n\n地图投影\n如果关注地图的准确性，利用经纬度在笛卡尔平面上进行绘制并非最佳办法，至少存在两个基本问题：\n\n地球既不是一个平面，也不是一个完美的球体。关于地球形状的一系列假设被称为大地基准，虽然它对某些数据的可视化可能并不重要，但对其他数据来说，它是至关重要的。有几种不同的选择可以考虑：如果重点是北美，“北美基准”（NAD83）是一个很好的选择；如果视角是全球，“世界大地测量系统”（WGS84）可能更好。\n地图的形状。地球近似椭圆体，但大多数情况下，空间数据需要绘制在一个二维平面上。不可能在不发生扭曲或切割的情况下把椭圆体的表面映射到一个平面上，因此必须对扭曲作出选择。这就是地图投影的工作。\n\n地图投影通常按照它们保留的几何属性来分类，例如：\n\n\n面积保护型投影确保地球上面积相等的区域在地图上的绘制面积相等。\n\n形状保护型（保形或保角）投影确保区域的局部形状得到保留。\n\n\n\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support for Spatial Vector Data” 10. https://doi.org/10.32614/RJ-2018-009.\n\n\nTeucher, Andy, and Kenton Russell. 2022. “Rmapshaper: Client for ’Mapshaper’ for ’Geospatial’ Operations.” https://CRAN.R-project.org/package=rmapshaper.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org."
  },
  {
    "objectID": "Finance.html",
    "href": "Finance.html",
    "title": "Finance",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "fin-tidy.html",
    "href": "fin-tidy.html",
    "title": "\n2  Tidy Finance with R\n",
    "section": "",
    "text": "原先的笔记在这里，会迁移过来。"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Pebesma, Edzer. 2018. “Simple Features for r:\nStandardized Support for Spatial Vector Data” 10. https://doi.org/10.32614/RJ-2018-009.\n\n\nTeucher, Andy, and Kenton Russell. 2022. “Rmapshaper: Client for\n’Mapshaper’ for ’Geospatial’ Operations.” https://CRAN.R-project.org/package=rmapshaper.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data\nAnalysis.” https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data\nScience. O’Reilly Media."
  }
]