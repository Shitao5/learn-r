[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn-R",
    "section": "",
    "text": "License\n\n本书作为整体在知识共享署名-非商业性-相同方式共享4.0国际许可证下授权。\n本书包含的代码在MIT 许可证下提供；这意味着你可以在引用来源的情况下自由使用。\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. O’Reilly Media."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "本书内容包括数据可视化、金融。"
  },
  {
    "objectID": "Visualisation.html",
    "href": "Visualisation.html",
    "title": "Visualisation",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "vis-ggplot2.html",
    "href": "vis-ggplot2.html",
    "title": "\n1  ggplot2\n",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节正在进行写作和结构调整，可能出现混乱或不完整的情况。\nggplot2(Wickham 2016)具有底层的图形语法，ggplot2: Elegant Graphics for Data Analysis重点解释了这套语法， 本章节为其学习笔记。"
  },
  {
    "objectID": "vis-ggplot2.html#ggplot2初步",
    "href": "vis-ggplot2.html#ggplot2初步",
    "title": "\n1  ggplot2\n",
    "section": "\n1.1 ggplot2初步",
    "text": "1.1 ggplot2初步\nggplot2具有颜色（color）、大小（size）、形状（shape）、填充（fill）等美学属性，适用于不同类型的图形。\n在绘图美学中，少即是多，使用美学映射需要节制。与其用一幅非常复杂的图形一次展示所有，不如创造一些简单的情节，讲述一个故事，让读者的认识从无到有。"
  },
  {
    "objectID": "vis-ggplot2.html#图层layers",
    "href": "vis-ggplot2.html#图层layers",
    "title": "\n1  ggplot2\n",
    "section": "\n1.2 图层（Layers）",
    "text": "1.2 图层（Layers）\nggplot2的分层结构1使得我们可以以结构化的方式设计和构建图形。一般来说，图层有三个功能：\n\n展示数据\n展示数据的统计摘要\n添加额外的元数据：背景、注释和参考文献。\n\n\n1.2.1 基本图形\n\ndf <- data.frame(\n  x = c(3, 1, 5),\n  y = c(2, 4, 6),\n  label = c(\"a\", \"b\", \"c\")\n)\n\np <- ggplot(df, aes(x, y, label = label)) +\n  labs(x = NULL, y = NULL) +\n  theme(plot.title = element_text(size = 12))\n\np + geom_point() + ggtitle(\"point\")\np + geom_text() + ggtitle(\"text\")\np + geom_bar(stat = \"identity\") + ggtitle(\"bar\")\np + geom_tile() + ggtitle(\"raster\")\n\np + geom_line() + ggtitle(\"line\")\np + geom_area() + ggtitle(\"area\")\np + geom_path() + ggtitle(\"path\")\np + geom_polygon() + ggtitle(\"polygon\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.2 揭示不确定性\n根据x轴是否连续和是否展示中间值，比较基本的有：\n\ndf <- data.frame(x = 1:3,\n                 y = c(18, 11, 16),\n                 se = c(1.2, .5, 1.0))\n\nbase <- ggplot(df, aes(x, y,\n                       ymin = y - se,\n                       ymax = y + se))\nbase + geom_crossbar()\nbase + geom_pointrange()\nbase + geom_smooth(stat = \"identity\")\n\nbase + geom_errorbar()\nbase + geom_linerange()\nbase + geom_ribbon()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.3 权重数据\n汇总数据的每一行代表多个观测值，因此需要考虑权重变量。权重变量的选择将影响绘图和得出的结论。\n对于点图、线图等简单图形，使用大小（size)美学。\n\n# Unweighted\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point()\n\n# Weighted by population\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point(aes(size = poptotal / 1e6)) +\n  scale_size_area(\"Population\\n(millions)\",\n                  breaks = c(.5, 1, 2, 4))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对于涉及统计转换等复杂图形，使用weight美学指定权重。权重支持平滑、量化回归、箱型图、直方图、密度图等情形。我们无法直接从图中看出权重变量，它也不会产生图例，但会改变统计汇总的结果。\n\n# Unweighted\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point() +\n  geom_smooth(method = lm, size = 1)\n\n# Weighted by population\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point(aes(size = poptotal / 1e6)) +\n  geom_smooth(aes(weight = poptotal), method = lm, size = 1) +\n  scale_size_area(guide = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.2.4 地图\n\n\n\n\n\n\nNote\n\n\n\n这里部分内容不甚熟悉，因此有大段的原文翻译。\n\n\n绘制地理空间数据是一项常见的可视化任务，它需要专门的工作。通常来讲，可以把任务分成两步：\n\n使用数据源绘制地图；\n从信息源添加元数据到地图上。\n\nR语言内置了地图包，虽然不是最新的，但是一个好的起点。这里从中提取密歇根州的县界：\n\nlibrary(tidyverse) # 用于数据处理\nmi_counties <- map_data(\"county\", \"michigan\") %>% \n  select(lon = long, lat, group, id = subregion)\nhead(mi_counties)\n#>     lon  lat group     id\n#> 1 -83.9 44.9     1 alcona\n#> 2 -83.4 44.9     1 alcona\n#> 3 -83.4 44.9     1 alcona\n#> 4 -83.3 44.8     1 alcona\n#> 5 -83.3 44.8     1 alcona\n#> 6 -83.3 44.8     1 alcona\n\n利用散点图可以看到数据集中每个县的角落，通过geom_polygon()将散点图绘制成地图：\n\nggplot(mi_counties, aes(lon, lat)) +\n  geom_point(size = .25, show.legend = FALSE) +\n  coord_quickmap()\n\nggplot(mi_counties, aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"grey50\") +\n  coord_quickmap()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncoord_quickmap()调整坐标轴，以确保经度和纬度在同一比例上呈现。但地理空间数据往往需要更精准的方法，因此ggplot2提供了geom_sf()和coord_sf()来处理简单特征格式的空间数据。\nSimple feature maps\n上述方法具有局限性，最典型的是：现实世界的地图不是简单地按照”经度-纬度”的数据格式绘制的。 地图的矢量数据通常使用由开放地理空间联盟制定的”简单特征”（simple features）标准进行编码。 sf包(Pebesma 2018)为处理这类数据提供了优质的工具集，ggplot2中的geom_sf()和coord_sf()函数就是为与sf包一起工作而设计的。\n\nlibrary(ozmaps) # 提供澳大利亚的地图数据\nlibrary(sf)\n\nozmap_states\n#> Simple feature collection with 9 features and 1 field\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 106 ymin: -43.6 xmax: 168 ymax: -9.23\n#> Geodetic CRS:  GDA94\n#> # A tibble: 9 × 2\n#>   NAME                                                      geometry\n#> * <chr>                                           <MULTIPOLYGON [°]>\n#> 1 New South Wales              (((151 -35.1, 151 -35.1, 151 -35.1, …\n#> 2 Victoria                     (((147 -38.7, 147 -38.7, 147 -38.7, …\n#> 3 Queensland                   (((149 -20.3, 149 -20.4, 149 -20.4, …\n#> 4 South Australia              (((137 -34.5, 137 -34.5, 137 -34.5, …\n#> 5 Western Australia            (((126 -14, 126 -14, 126 -14, 126 -1…\n#> 6 Tasmania                     (((148 -40.3, 148 -40.3, 148 -40.3, …\n#> 7 Northern Territory           (((136 -13.8, 136 -13.8, 136 -13.8, …\n#> 8 Australian Capital Territory (((149 -35.2, 149 -35.2, 149 -35.3, …\n#> 9 Other Territories            (((168 -29.1, 168 -29, 168 -29, 168 …\n\nsf数据的一个优势，在于我们可以直观地看到数据的整体结构。澳大利亚由6个州和一些地区组成，共9个地理单元，因此数据中有9行。geometry列的每个元素都是一个多边形对象，指定一个或多个多边形顶点，标示着一个地区的边界。\n对于这种格式的数据，我们可以使用geom_sf()和coord_sf()绘制一张可用的地图而不需要制定任何参数，甚至不需要明确美学。\n\nggplot(ozmap_states) +\n  geom_sf() +\n  coord_sf()\n\n\n\n\n\n\n\ngeom_sf()使用ggplot2中其他地方没有使用的geometry美学，这种美学可以通过以下三种方式之一来制定。\n\n用户无需任何操作，geom_sf()自动将名为geometry的列映射到地图中。\n如果数据是一个sf对象，geom_sf()自动检测geometry格式的列，即使该列名不为geometry。\n使用aes(geometry = my_column)手动指定映射，在数据中有多个geometry格式的列时很有用。\n\nggplot2支持多层geom_sf()叠加。使用rmapshaper包(Teucher and Russell 2022)简化边界，以减少渲染绘图的时间。当原始数据集（本例中为abs_ced）的存储分辨率高于绘图要求时，这通常是个好主意。\n\noz_states <- ozmap_states %>% filter(NAME != \"Other Territories\")\noz_votes <- rmapshaper::ms_simplify(abs_ced)\n#> Registered S3 method overwritten by 'geojsonlint':\n#>   method         from \n#>   print.location dplyr\n\nggplot() +\n  geom_sf(data = oz_states, mapping = aes(fill = NAME), show.legend = FALSE) +\n  geom_sf(data = oz_votes, fill = NA) +\n  coord_sf()\n\n\n\n\n\n\n\n图上添加标签：\n\nsydney_map <- abs_ced %>% filter(NAME %in% c(\n  \"Sydney\", \"Wentworth\", \"Warringah\", \"Kingsford Smith\", \"Grayndler\", \"Lowe\", \n  \"North Sydney\", \"Barton\", \"Bradfield\", \"Banks\", \"Blaxland\", \"Reid\", \n  \"Watson\", \"Fowler\", \"Werriwa\", \"Prospect\", \"Parramatta\", \"Bennelong\", \n  \"Mackellar\", \"Greenway\", \"Mitchell\", \"Chifley\", \"McMahon\"\n))\n\nggplot(sydney_map) +\n  geom_sf(aes(fill = NAME), show.legend = FALSE) +\n  coord_sf(xlim = c(150.97, 151.3), ylim = c(-33.98, -33.79)) +\n  geom_sf_label(aes(label = NAME), label.padding = unit(1, \"mm\"))\n#> Warning in st_point_on_surface.sfc(sf::st_zm(x)):\n#> st_point_on_surface may not give correct results for\n#> longitude/latitude data\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\ngeom_sf_label()函数内部使用sf包中的函数st_point_on_surface()来放置标签，出现上述警告是因为sf用于计算几何量（例如中心点、内部点）的大多数算法都是基于这样一个假设：点位于一个平坦的二维表面上，并以笛卡尔坐标作为参数。这种假设并不严格，在某些情况下（例如，靠近两极的地区），以这种方式处理经度和纬度的计算会得到错误的答案。因此，sf软件包在依赖这种近似方式进行计算时将产生警告。\n\n\n添加其他图层：\n\noz_capitals <- tibble::tribble( \n  ~city,           ~lat,     ~lon,\n  \"Sydney\",    -33.8688, 151.2093,  \n  \"Melbourne\", -37.8136, 144.9631, \n  \"Brisbane\",  -27.4698, 153.0251, \n  \"Adelaide\",  -34.9285, 138.6007, \n  \"Perth\",     -31.9505, 115.8605, \n  \"Hobart\",    -42.8821, 147.3272, \n  \"Canberra\",  -35.2809, 149.1300, \n  \"Darwin\",    -12.4634, 130.8456, \n)\n\nggplot() + \n  geom_sf(data = oz_votes) + \n  geom_sf(data = oz_states, colour = \"black\", fill = NA) + \n  geom_point(data = oz_capitals, mapping = aes(x = lon, y = lat), colour = \"red\") + \n  coord_sf()\n\n\n\n\n\n\n\n地图投影\n如果关注地图的准确性，利用经纬度在笛卡尔平面上进行绘制并非最佳办法，至少存在两个基本问题：\n\n地球既不是一个平面，也不是一个完美的球体。关于地球形状的一系列假设被称为大地基准，虽然它对某些数据的可视化可能并不重要，但对其他数据来说，它是至关重要的。有几种不同的选择可以考虑：如果重点是北美，“北美基准”（NAD83）是一个很好的选择；如果视角是全球，“世界大地测量系统”（WGS84）可能更好。\n地图的形状。地球近似椭圆体，但大多数情况下，空间数据需要绘制在一个二维平面上。不可能在不发生扭曲或切割的情况下把椭圆体的表面映射到一个平面上，因此必须对扭曲作出选择。这就是地图投影的工作。 地图投影通常按照它们保留的几何属性来分类，例如：\n\n\n\n面积保护型投影确保地球上面积相等的区域在地图上的绘制面积相等。\n\n形状保护型（保形或保角）投影确保区域的局部形状得到保留。\n\n任何投影都无法做到既保形又保面积，sf允许我们可以指定想使用的地图投影。关于地图投影的更多信息，参见Geocomputation with R。\n综上，大地基准（如WGS84）、地图投影类型（如墨卡托）和投影参数（如原点位置）共同指定了一个坐标参考系统（coordinate reference system，CRS）。这是一套用于将经纬度信息转换为二维地图的完整假设。一个sf对象通常包括一个默认的CRS，如下所示：\n\nst_crs(oz_votes)\n#> Coordinate Reference System:\n#>   User input: EPSG:4283 \n#>   wkt:\n#> GEOGCRS[\"GDA94\",\n#>     DATUM[\"Geocentric Datum of Australia 1994\",\n#>         ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#>             LENGTHUNIT[\"metre\",1]]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"Horizontal component of 3D system.\"],\n#>         AREA[\"Australia including Lord Howe Island, Macquarie Islands, Ashmore and Cartier Islands, Christmas Island, Cocos (Keeling) Islands, Norfolk Island. All onshore and offshore.\"],\n#>         BBOX[-60.56,93.41,-8.47,173.35]],\n#>     ID[\"EPSG\",4283]]\n\n这些输出大多对应于一个众所周知的文本（well-know text，WKT）字符串，它详细描述了CRS。sf内部使用这种冗长的WKT表示法，但是有几种方法可以提供sf理解的用户输入。其中一种方法是以EPSG代码的形式提供数字输入。oz_votes数据中的默认CRS与EPSG代码4283相对应。\n\nst_crs(oz_votes) == st_crs(4283)\n#> [1] TRUE\n\n在ggplot2中，coord_sf()控制CRS，以确保每一层都使用相同的投影。sf数据通常会提供一个合理的CRS选择，coord_sf()默认使用数据geometry列相关的CRS。当需要指定CRS时，可以通过向st_crs()传递crs参数：\n\nggplot(oz_votes) + geom_sf()\nggplot(oz_states) + geom_sf() + coord_sf(crs = st_crs(3112))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRaster maps\n绘制地理空间信息的第二种方式是依靠栅格数据（raster data）。与sf数据不同，栅格数据中，地理实体是以一组线、点和多边形的形式来指定的，而栅格则是以图像的形式出现。在最简单的情况下，光栅数据可能是一个有许多不同的图像格式位图文件。具体到地理空间方面，有一些图像格式包括元数据（如大地测量基准、坐标参考系统），可用于将图像信息映射到地球表面。\n在GDAL（地理空间数据抽象库）的帮助下，大多数格式可以很容易地读入R。例如，sf包中的sf::gdal_read()函数提供了从R中访问GDAL的功能。不过，很少需要直接调用这个函数，因为还有其他高级函数可以处理这个问题。\n举个例子，假设我们想绘制澳大利亚气象局（BOM）在其FTP服务器上公开提供的卫星图像。bomrang包(Sparks et al. 2017)提供了一个方便的服务器接口，包括一个返回文件名向量的get_available_imagery()函数和一个下载文件并直接导入R中的get_satellite_imagery()函数。\n这里使用更灵活的方式，可以适用任何FTP服务器，并使用download.file()函数：\n\n# list of all file names with time stamp 2022-08-04 21:00 GMT \n# (BOM images are retained for 24 hours, so this will return an\n# empty vector if you run this code without editing the time stamp)\nfiles <- bomrang::get_available_imagery() %>% \n  str_subset(\"202208042100\")\n\nwalk2(\n  .x = paste0(\"ftp://ftp.bom.gov.au/anon/gen/gms/\", files),\n  .y = file.path(\"raster\", files),\n  .f = ~ download.file(url = .x, destfile = .y)\n)\n\n所有14个文件2都是由日本气象厅运营的Himawari-8地球静止卫星拍摄的图像构建的，并在13个不同的波段拍摄图像。澳大利亚BOM发布的图像包括可见光谱（频道3）和红外光谱（频道13）的数据。\n为了将可见图片导入R，使用stars包(Pebesma 2022)将其导入为stars对象：\n\nimg_vis  <- file.path(\"raster\", \"IDE00422.202208042100.tif\")\nimg_inf <- file.path(\"raster\", \"IDE00421.202208042100.tif\")\n\nlibrary(stars)\nsat_vis <- read_stars(img_vis, RasterIO = list(nBufXSize = 600, nBufYSize = 600))\nsat_inf <- read_stars(img_inf, RasterIO = list(nBufXSize = 600, nBufYSize = 600))\n\nRasterIO参数用来向GDAL传递一列低级参数，使用了nBufXSize和nBufYSize来确保R以低分辨率读取数据（作为600x600像素的图像）。\n\nsat_vis\n#> stars object with 3 dimensions and 1 attribute\n#> attribute(s), summary of first 1e+05 cells:\n#>                            Min. 1st Qu. Median Mean 3rd Qu. Max.\n#> IDE00422.202208042100.tif     0       0      0 37.9      52  255\n#> dimension(s):\n#>      from  to   offset    delta                  refsys point\n#> x       1 600 -5500000  18333.3 Geostationary_Satellite FALSE\n#> y       1 600  5500000 -18333.3 Geostationary_Satellite FALSE\n#> band    1   3       NA       NA                      NA    NA\n#>      values x/y\n#> x      NULL [x]\n#> y      NULL [y]\n#> band   NULL\n\n注意，空间数据也与一个坐标参考系统相关联（在输出中被称为 “refsys”）。\n利用stars包提供的geom_stars()函数，可以使用ggplot2进行绘图：\n\nggplot() +\n  geom_stars(data = sat_vis) +\n  coord_equal()\n\n\n\n\n\n\n\ngeom_stars()函数要求数据是stars对象，并将栅格数据映射到填充（fill）美学。因此，上面的卫星图像中的蓝色阴影是由ggplot2的比例决定的，而不是图像本身。也就是说，尽管sat_vis包含三个波段，但上面的绘图只显示第一个波段，原始数据值（范围从0到255）被映射到ggplot2用于连续数据的默认蓝色调色板上。为了看到图像文件的真实面貌，我们可以用facet_wrap()分离这些波段：\n\nggplot() +\n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  facet_wrap(vars(band)) +\n  coord_equal() +\n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n只显示原始图像不易弄清楚相关的陆地在哪里，我们可能希望将卫星数据与oz_states矢量地图重叠，以显示澳大利亚政治实体的轮廓。这样做需注意，这两个数据源具有不同的坐标参考系统。为了正确投影oz_states的数据，需使用sf包中的st_transform()函数对数据进行转换。下面的代码将从sat_vis栅格对象中提取CRS，并应用于oz_states，而后进行可视化：\n\noz_states <- st_transform(oz_states, crs = st_crs(sat_vis))\n\nggplot() +\n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  geom_sf(data = oz_states, fill = NA, color = \"white\") +\n  coord_sf() +\n  theme_void() +\n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n可以看到在这个拍摄时间，澳大利亚即将日出。\n如何在上面绘制更多的常规数据呢？一个简单的例子是根据包含经纬度的oz_capitals数据框来绘制澳大利亚首都的位置。然而，由于这些数据没有与CRS相关联，并且与sat_vis中的栅格数据的比例不一样，所以这些数据也需要进行转换。为此，首先需要使用st_as_sf()从oz_capitals数据中创建sf对象：\n\ncities <- oz_capitals %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326, remove = FALSE)\n\n这个投影是使用EPSG代码4326设置的，这是使用经纬度值作为坐标并依靠WGS84基准的椭圆形投影。而后可以将经纬度几何坐标转换为与sat_vis数据的几何形状相匹配。\n\ncities <- st_transform(cities, st_crs(sat_vis))\n\nggplot() +\n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  geom_sf(data = oz_states, fill = NA, color = \"white\") +\n  geom_sf(data = cities, color = \"red\") +\n  coord_sf() +\n  theme_void() +\n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n如果有自己的形状文件（.shp），可以用sf::read_sf()把它们加载到R中。\n\n1.2.5 网络图\n网络在可视化中占据了一席之地，和地图、空间数据一样，网络具有特定的数据结构和可视化范式，ggplot2并不直接支持网络图，接下来将使用ggraph包(Pedersen 2021)进行网络的可视化。\n网络数据\n网络数据可以编码为两个相互关联的数据帧，分别编码节点和边，这就是tidygraph包(Pedersen 2022)使用的方法，它是ggraph的基础数据处理包。\n\nlibrary(tidygraph)\nlibrary(ggraph)\n\ngraph <- play_erdos_renyi(n = 10, p = .2) %>% \n  activate(nodes) %>% \n  mutate(class = sample(letters[1:4], n(), replace = TRUE)) %>% \n  activate(edges) %>% \n  arrange(.N()$class[from])\ngraph\n#> # A tbl_graph: 10 nodes and 15 edges\n#> #\n#> # A directed simple graph with 1 component\n#> #\n#> # Edge Data: 15 × 2 (active)\n#>    from    to\n#>   <int> <int>\n#> 1     8     3\n#> 2     3     8\n#> 3     2    10\n#> 4     2     4\n#> 5     4     6\n#> 6     9     6\n#> # … with 9 more rows\n#> #\n#> # Node Data: 10 × 1\n#>   class\n#>   <chr>\n#> 1 d    \n#> 2 c    \n#> 3 b    \n#> # … with 7 more rows\n\n一些新函数：activate()指定在网络的哪个部分工作（节点或者边）；即使在处理边的时候，.N()也可以访问当前图形的节点数据（与之对应的.E()函数访问边的数据，以及.G()访问整个图形）。\ntidygraph包的as_tbl_graph()可以将大部分不同形式的网络数据进行转换:\n\nhead(highschool)\n#>   from to year\n#> 1    1 14 1957\n#> 2    1 15 1957\n#> 3    1 21 1957\n#> 4    1 54 1957\n#> 5    1 55 1957\n#> 6    2 21 1957\n\nhs_graph <- as_tbl_graph(highschool, directed = FALSE) # 不带方向\nhs_graph\n#> # A tbl_graph: 70 nodes and 506 edges\n#> #\n#> # An undirected multigraph with 1 component\n#> #\n#> # Node Data: 70 × 1 (active)\n#>   name \n#>   <chr>\n#> 1 1    \n#> 2 2    \n#> 3 3    \n#> 4 4    \n#> 5 5    \n#> 6 6    \n#> # … with 64 more rows\n#> #\n#> # Edge Data: 506 × 3\n#>    from    to  year\n#>   <int> <int> <dbl>\n#> 1     1    13  1957\n#> 2     1    14  1957\n#> 3     1    20  1957\n#> # … with 503 more rows\n\n\nluv_clust <- hclust(dist(luv_colours[, 1:3]))\nluv_graph <- as_tbl_graph(luv_clust)\nluv_graph\n#> # A tbl_graph: 1313 nodes and 1312 edges\n#> #\n#> # A rooted tree\n#> #\n#> # Node Data: 1,313 × 4 (active)\n#>   height leaf  label members\n#>    <dbl> <lgl> <chr>   <int>\n#> 1     0  TRUE  \"101\"       1\n#> 2     0  TRUE  \"427\"       1\n#> 3   778. FALSE \"\"          2\n#> 4     0  TRUE  \"571\"       1\n#> 5     0  TRUE  \"426\"       1\n#> 6     0  TRUE  \"424\"       1\n#> # … with 1,307 more rows\n#> #\n#> # Edge Data: 1,312 × 2\n#>    from    to\n#>   <int> <int>\n#> 1     3     1\n#> 2     3     2\n#> 3     8     6\n#> # … with 1,309 more rows\n\n我们可以看到，tidygraph在转换时自动添加了额外的信息，例如，highschool数据中的year列，以及分层聚类luv_clust中的label和leaf节点。\n\n# 中心度计算\ngraph %>% \n  activate(nodes) %>% \n  mutate(centrality = centrality_pagerank()) %>% \n  arrange(desc(centrality))\n#> # A tbl_graph: 10 nodes and 15 edges\n#> #\n#> # A directed simple graph with 1 component\n#> #\n#> # Node Data: 10 × 2 (active)\n#>   class centrality\n#>   <chr>      <dbl>\n#> 1 a         0.326 \n#> 2 b         0.316 \n#> 3 c         0.0595\n#> 4 d         0.0569\n#> 5 c         0.0526\n#> 6 d         0.0434\n#> # … with 4 more rows\n#> #\n#> # Edge Data: 15 × 2\n#>    from    to\n#>   <int> <int>\n#> 1     1     2\n#> 2     2     1\n#> 3     5     6\n#> # … with 12 more rows\n\ntidygraph支持一系列丰富的算法，比如中心度计算（哪个节点最中心）、排序（对节点进行排序，使节点位于与之相连的节点附近）、分组（在网络内寻找群组）等，具体见这里。\n网络图更关注拓扑结构而不是两个变量之间的关系，我们采用布局（Layouts）的概念来显示网络拓扑结构。布局是利用网络结构来计算每个节点的x和y值（通常是任意的）的算法，最终用于可视化。换句话说，在绘制表格数据时，x和y的美学几乎总是被数据中的现有变量（或现有数据的统计转换）映射，而在绘制网络数据时，x和y被来自网络拓扑结构的值映射，这些值本身没有意义。\n\nggraph(hs_graph) +\n  geom_edge_link() +\n  geom_node_point()\n#> Using `stress` as default layout\n\nggraph(hs_graph, layout = \"drl\") +\n  geom_edge_link() +\n  geom_node_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhs_graph <- hs_graph %>% \n  activate(edges) %>% \n  mutate(edge_weights = runif(n()))\nggraph(hs_graph, layout = \"stress\", weights = edge_weights) +\n  geom_edge_link(aes(alpha = edge_weights)) +\n  geom_node_point() +\n  scale_edge_alpha_identity()\n\n# 环形\nggraph(luv_graph, layout = \"dendrogram\", circular = TRUE) +\n  geom_edge_link() +\n  coord_fixed()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n绘制节点（nodes）\n\n# 只显示2个以上的节点，按中心度着色\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point(\n    aes(filter = centrality_degree() > 2,\n        color = centrality_power()),\n    size = 2\n  )\n\n# 树状图\nggraph(luv_graph, layout = \"treemap\") +\n  geom_node_tile(aes(fill = depth))\n#> Warning: Existing variables `height`, `leaf` overwritten by layout\n#> variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n绘制边缘（edges）\n\nggraph(graph, layout = \"stress\") +\n  geom_edge_link(aes(alpha = after_stat(index)))\n\nggraph(graph, layout = \"stress\") +\n  geom_edge_link2(\n    aes(color = node.class),\n    width = 3, lineend = \"round\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_fan()\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_parallel()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggraph(luv_graph, layout = \"dendrogram\", height = height) +\n  geom_edge_elbow()\n\nggraph(luv_graph, layout = \"dendrogram\", height = height) +\n  geom_edge_bend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 节点会遮盖箭头\nggraph(graph, layout = \"stress\") +\n  geom_edge_link(arrow = arrow()) +\n  geom_node_point(aes(color = class), size = 6)\n\n# 解决上述问题\nggraph(graph, layout = \"stress\") +\n  geom_edge_link(\n    arrow = arrow(),\n    start_cap = circle(3, \"mm\"),\n    end_cap = circle(3, \"mm\")\n  ) +\n  geom_node_point(aes(color = class), size = 6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n分面\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_edges(~year)\n\n\n\n\n\n\n\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_nodes(~ group_spinglass())\n\n\n\n\n\n\n\n\n1.2.6 注释（Annotations）\n从概念上讲，注释为绘图提供了元数据，它提供了关于数据的额外信息。\n图形和轴标题\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = factor(cyl))) +\n  labs(\n    x = \"Engine displacement (litres)\",\n    y = \"Highway miles per gallon\",\n    color = \"Number of cylinders\",\n    title = \"Mileage by engine size and cylinders\",\n    subtitle = \"Source: http://fueleconomy.gov\"\n  )\n\n\n\n\n\n\n\n通常给labs()提供文本字符串，并用\\n指定换行，也可以提供用quote()包裹的数学表达式：\n\nvalues <- seq(from = -2, to = 2, by = .01)\ndf <- data.frame(x = values, y = values ^ 3)\nggplot(df, aes(x, y)) +\n  geom_line() +\n  labs(y = quote(f(x) == x^3))\n\n\n\n\n\n\n\n在ggtext包(Wilke 2020)和ggplot2主题系统下，可以使用Markdown语法进行标记：\n\ndf <- data.frame(x = 1:3, y = 1:3)\nbase <- ggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(x = \"Axis title with *italics* and **boldface**\")\n\nbase\nbase + theme(axis.title.x = ggtext::element_markdown())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n❗未出现斜体和加粗效果，暂未发现原因。日后会处理。\n\n\n文本标签\n\n\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support for Spatial Vector Data” 10. https://doi.org/10.32614/RJ-2018-009.\n\n\n———. 2022. “Stars: Spatiotemporal Arrays, Raster and Vector Data Cubes.” https://CRAN.R-project.org/package=stars.\n\n\nPedersen, Thomas Lin. 2021. “Ggraph: An Implementation of Grammar of Graphics for Graphs and Networks.” https://CRAN.R-project.org/package=ggraph.\n\n\n———. 2022. “Tidygraph: A Tidy API for Graph Manipulation.” https://CRAN.R-project.org/package=tidygraph.\n\n\nSparks, Adam H, Mark Padgham, Hugh Parsonage, and Keith Pembleton. 2017. “Bomrang: Fetch Australian Government Bureau of Meteorology Weather Data” 2. https://doi.org/10.21105/joss.00411.\n\n\nTeucher, Andy, and Kenton Russell. 2022. “Rmapshaper: Client for ’Mapshaper’ for ’Geospatial’ Operations.” https://CRAN.R-project.org/package=rmapshaper.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org.\n\n\nWilke, Claus O. 2020. “Ggtext: Improved Text Rendering Support for ’Ggplot2’.” https://CRAN.R-project.org/package=ggtext."
  },
  {
    "objectID": "Shiny.html",
    "href": "Shiny.html",
    "title": "Shiny",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "shiny1.html",
    "href": "shiny1.html",
    "title": "\n2  Shiny\n",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "Finance.html",
    "href": "Finance.html",
    "title": "Finance",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "fin-tidy.html",
    "href": "fin-tidy.html",
    "title": "\n3  Tidy Finance with R\n",
    "section": "",
    "text": "原先的笔记在这里，会迁移过来。"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Pebesma, Edzer. 2018. “Simple Features for r:\nStandardized Support for Spatial Vector Data” 10. https://doi.org/10.32614/RJ-2018-009.\n\n\n———. 2022. “Stars: Spatiotemporal Arrays, Raster and Vector Data\nCubes.” https://CRAN.R-project.org/package=stars.\n\n\nPedersen, Thomas Lin. 2021. “Ggraph: An Implementation of Grammar\nof Graphics for Graphs and Networks.” https://CRAN.R-project.org/package=ggraph.\n\n\n———. 2022. “Tidygraph: A Tidy API for Graph Manipulation.”\nhttps://CRAN.R-project.org/package=tidygraph.\n\n\nSparks, Adam H, Mark Padgham, Hugh Parsonage, and Keith Pembleton. 2017.\n“Bomrang: Fetch Australian Government\nBureau of Meteorology Weather Data” 2. https://doi.org/10.21105/joss.00411.\n\n\nTeucher, Andy, and Kenton Russell. 2022. “Rmapshaper: Client for\n’Mapshaper’ for ’Geospatial’ Operations.” https://CRAN.R-project.org/package=rmapshaper.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data\nAnalysis.” https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data\nScience. O’Reilly Media.\n\n\nWilke, Claus O. 2020. “Ggtext: Improved Text Rendering Support for\n’Ggplot2’.” https://CRAN.R-project.org/package=ggtext."
  }
]