[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn-R",
    "section": "",
    "text": "License\n\n本书作为整体在知识共享署名-非商业性-相同方式共享4.0国际许可证下授权。\n本书包含的代码在MIT 许可证下提供；这意味着你可以在引用来源的情况下自由使用。\n\n\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. O’Reilly Media."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Preface",
    "section": "",
    "text": "本书内容包括数据可视化、金融。"
  },
  {
    "objectID": "Visualisation.html",
    "href": "Visualisation.html",
    "title": "Visualisation",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节正在进行写作和结构调整，可能出现混乱或不完整的情况。"
  },
  {
    "objectID": "Visualisation.html#ggplot2",
    "href": "Visualisation.html#ggplot2",
    "title": "Visualisation",
    "section": "ggplot2",
    "text": "ggplot2\nggplot2(Wickham 2016)具有底层的图形语法，ggplot2: Elegant Graphics for Data Analysis重点解释了这套语法，Chapter 1、Chapter 2、Chapter 3 为其学习笔记。\nggplot2具有颜色（color）、大小（size）、形状（shape）、填充（fill）等美学属性，适用于不同类型的图形。"
  },
  {
    "objectID": "Visualisation.html#echarts",
    "href": "Visualisation.html#echarts",
    "title": "Visualisation",
    "section": "echarts",
    "text": "echarts\necharts是一款开源的JavaScript可视化库，其在可交互图形的绘制上具有很强的灵活性。echarts4r包(Coene 2022)是利用R操作echarts进行绘图的工具包。\n关于JavaScript的使用，还需阅读一下JavaScript for R，列入俺的TODO🐢。\n\n\n\n\nCoene, John. 2022. “Echarts4r: Create Interactive Graphs with ’Echarts JavaScript’ Version 5.” https://CRAN.R-project.org/package=echarts4r.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data Analysis.” https://ggplot2.tidyverse.org."
  },
  {
    "objectID": "vis-ggplot2-layers.html",
    "href": "vis-ggplot2-layers.html",
    "title": "1  ggplot2-layers",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前正在进行润色，基本是可读的。\n在绘图美学中，少即是多，使用美学映射需要节制。与其用一幅非常复杂的图形一次展示所有，不如创造一些简单的情节，讲述一个故事，让读者的认识从无到有。\nggplot2的分层结构1使得我们可以以结构化的方式设计和构建图形。一般来说，图层有三个功能："
  },
  {
    "objectID": "vis-ggplot2-layers.html#基本图形",
    "href": "vis-ggplot2-layers.html#基本图形",
    "title": "1  ggplot2-layers",
    "section": "\n1.1 基本图形",
    "text": "1.1 基本图形\n\ndf <- data.frame(\n  x = c(3, 1, 5),\n  y = c(2, 4, 6),\n  label = c(\"a\", \"b\", \"c\")\n)\n\np <- ggplot(df, aes(x, y, label = label)) +\n  labs(x = NULL, y = NULL) +\n  theme(plot.title = element_text(size = 12))\n\np + geom_point() + ggtitle(\"point\")\np + geom_text() + ggtitle(\"text\")\np + geom_bar(stat = \"identity\") + ggtitle(\"bar\")\np + geom_tile() + ggtitle(\"raster\")\n\np + geom_line() + ggtitle(\"line\")\np + geom_area() + ggtitle(\"area\")\np + geom_path() + ggtitle(\"path\")\np + geom_polygon() + ggtitle(\"polygon\")"
  },
  {
    "objectID": "vis-ggplot2-layers.html#揭示不确定性",
    "href": "vis-ggplot2-layers.html#揭示不确定性",
    "title": "1  ggplot2-layers",
    "section": "\n1.2 揭示不确定性",
    "text": "1.2 揭示不确定性\n根据x轴是否连续和是否展示中间值，比较基本的有：\n\ndf <- data.frame(x = 1:3,\n                 y = c(18, 11, 16),\n                 se = c(1.2, .5, 1.0))\n\nbase <- ggplot(df, aes(x, y,\n                       ymin = y - se,\n                       ymax = y + se))\nbase + geom_crossbar()\nbase + geom_pointrange()\nbase + geom_smooth(stat = \"identity\")\n\nbase + geom_errorbar()\nbase + geom_linerange()\nbase + geom_ribbon()"
  },
  {
    "objectID": "vis-ggplot2-layers.html#权重数据",
    "href": "vis-ggplot2-layers.html#权重数据",
    "title": "1  ggplot2-layers",
    "section": "\n1.3 权重数据",
    "text": "1.3 权重数据\n汇总数据的每一行代表多个观测值，因此需要考虑权重变量。权重变量的选择将影响绘图和得出的结论。\n对于点图、线图等简单图形，使用大小（size）美学。\n\n# Unweighted\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point()\n\n# Weighted by population\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point(aes(size = poptotal / 1e6)) +\n  scale_size_area(\"Population\\n(millions)\",\n                  breaks = c(.5, 1, 2, 4))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对于涉及统计转换等复杂图形，使用weight美学指定权重。权重支持平滑、量化回归、箱型图、直方图、密度图等情形。我们无法直接从图中看出权重变量，它也不会产生图例，但会改变统计汇总的结果。\n\n# Unweighted\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point() +\n  geom_smooth(method = lm, size = 1)\n\n# Weighted by population\nggplot(midwest, aes(percwhite, percbelowpoverty)) +\n  geom_point(aes(size = poptotal / 1e6)) +\n  geom_smooth(aes(weight = poptotal), method = lm, size = 1) +\n  scale_size_area(guide = \"none\")"
  },
  {
    "objectID": "vis-ggplot2-layers.html#地图",
    "href": "vis-ggplot2-layers.html#地图",
    "title": "1  ggplot2-layers",
    "section": "\n1.4 地图",
    "text": "1.4 地图\n\n\n\n\n\n\nNote\n\n\n\n这里部分内容不甚熟悉，因此有大段的原文翻译。\n\n\n绘制地理空间数据是一项常见的可视化任务，它需要专门的工作。通常来讲，可以把任务分成两步：\n\n使用数据源绘制地图；\n从信息源添加元数据到地图上。\n\nR语言内置了地图包，虽然不是最新的，但是一个好的起点。这里从中提取密歇根州的县界：\n\nlibrary(tidyverse) # 用于数据处理\nmi_counties <- map_data(\"county\", \"michigan\") %>% \n  select(lon = long, lat, group, id = subregion)\nhead(mi_counties)\n#>     lon  lat group     id\n#> 1 -83.9 44.9     1 alcona\n#> 2 -83.4 44.9     1 alcona\n#> 3 -83.4 44.9     1 alcona\n#> 4 -83.3 44.8     1 alcona\n#> 5 -83.3 44.8     1 alcona\n#> 6 -83.3 44.8     1 alcona\n\n利用散点图可以看到数据集中每个县的角落，通过geom_polygon()将散点图绘制成地图：\n\nggplot(mi_counties, aes(lon, lat)) +\n  geom_point(size = .25, show.legend = FALSE) +\n  coord_quickmap()\n\nggplot(mi_counties, aes(lon, lat, group = group)) +\n  geom_polygon(fill = \"white\", color = \"grey50\") +\n  coord_quickmap()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncoord_quickmap()调整坐标轴，以确保经度和纬度在同一比例上呈现。但地理空间数据往往需要更精准的方法，因此ggplot2提供了geom_sf()和coord_sf()来处理简单特征格式的空间数据。\n\n1.4.1 Simple feature maps\n上述方法具有局限性，最典型的是：现实世界的地图不是简单地按照”经度-纬度”的数据格式绘制的。 地图的矢量数据通常使用由开放地理空间联盟制定的”简单特征”（simple features）标准进行编码。 sf包(Pebesma 2018)为处理这类数据提供了优质的工具集，ggplot2中的geom_sf()和coord_sf()函数就是为与sf包一起工作而设计的。\n\nlibrary(ozmaps) # 提供澳大利亚的地图数据\nlibrary(sf)\n#> Linking to GEOS 3.9.1, GDAL 3.4.3, PROJ 7.2.1; sf_use_s2() is TRUE\n\nozmap_states\n#> Simple feature collection with 9 features and 1 field\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 106 ymin: -43.6 xmax: 168 ymax: -9.23\n#> Geodetic CRS:  GDA94\n#> # A tibble: 9 × 2\n#>   NAME                                                      geometry\n#> * <chr>                                           <MULTIPOLYGON [°]>\n#> 1 New South Wales              (((151 -35.1, 151 -35.1, 151 -35.1, …\n#> 2 Victoria                     (((147 -38.7, 147 -38.7, 147 -38.7, …\n#> 3 Queensland                   (((149 -20.3, 149 -20.4, 149 -20.4, …\n#> 4 South Australia              (((137 -34.5, 137 -34.5, 137 -34.5, …\n#> 5 Western Australia            (((126 -14, 126 -14, 126 -14, 126 -1…\n#> 6 Tasmania                     (((148 -40.3, 148 -40.3, 148 -40.3, …\n#> 7 Northern Territory           (((136 -13.8, 136 -13.8, 136 -13.8, …\n#> 8 Australian Capital Territory (((149 -35.2, 149 -35.2, 149 -35.3, …\n#> 9 Other Territories            (((168 -29.1, 168 -29, 168 -29, 168 …\n\nsf数据的一个优势，在于我们可以直观地看到数据的整体结构。澳大利亚由6个州和一些地区组成，共9个地理单元，因此数据中有9行。geometry列的每个元素都是一个多边形对象，指定一个或多个多边形顶点，标示着一个地区的边界。\n对于这种格式的数据，我们可以使用geom_sf()和coord_sf()绘制一张可用的地图而不需要制定任何参数，甚至不需要明确美学。\n\nggplot(ozmap_states) +\n  geom_sf() +\n  coord_sf()\n\n\n\n\n\n\n\ngeom_sf()使用ggplot2中其他地方没有使用的geometry美学，这种美学可以通过以下三种方式之一来制定。\n\n用户无需任何操作，geom_sf()自动将名为geometry的列映射到地图中。\n如果数据是一个sf对象，geom_sf()自动检测geometry格式的列，即使该列名不为geometry。\n使用aes(geometry = my_column)手动指定映射，在数据中有多个geometry格式的列时很有用。\n\nggplot2支持多层geom_sf()叠加。使用rmapshaper包(Teucher and Russell 2022)简化边界，以减少渲染绘图的时间。当原始数据集（本例中为abs_ced）的存储分辨率高于绘图要求时，这通常是个好主意。\n\noz_states <- ozmap_states %>% filter(NAME != \"Other Territories\")\noz_votes <- rmapshaper::ms_simplify(abs_ced)\n#> Registered S3 method overwritten by 'geojsonlint':\n#>   method         from \n#>   print.location dplyr\n\nggplot() +\n  geom_sf(data = oz_states, mapping = aes(fill = NAME), show.legend = FALSE) +\n  geom_sf(data = oz_votes, fill = NA) +\n  coord_sf()\n\n\n\n\n\n\n\n图上添加标签：\n\nsydney_map <- abs_ced %>% filter(NAME %in% c(\n  \"Sydney\", \"Wentworth\", \"Warringah\", \"Kingsford Smith\", \"Grayndler\", \"Lowe\", \n  \"North Sydney\", \"Barton\", \"Bradfield\", \"Banks\", \"Blaxland\", \"Reid\", \n  \"Watson\", \"Fowler\", \"Werriwa\", \"Prospect\", \"Parramatta\", \"Bennelong\", \n  \"Mackellar\", \"Greenway\", \"Mitchell\", \"Chifley\", \"McMahon\"\n))\n\nggplot(sydney_map) +\n  geom_sf(aes(fill = NAME), show.legend = FALSE) +\n  coord_sf(xlim = c(150.97, 151.3), ylim = c(-33.98, -33.79)) +\n  geom_sf_label(aes(label = NAME), label.padding = unit(1, \"mm\"))\n#> Warning in st_point_on_surface.sfc(sf::st_zm(x)):\n#> st_point_on_surface may not give correct results for\n#> longitude/latitude data\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\ngeom_sf_label()函数内部使用sf包中的函数st_point_on_surface()来放置标签，出现上述警告是因为sf用于计算几何量（例如中心点、内部点）的大多数算法都是基于这样一个假设：点位于一个平坦的二维表面上，并以笛卡尔坐标作为参数。这种假设并不严格，在某些情况下（例如，靠近两极的地区），以这种方式处理经度和纬度的计算会得到错误的答案。因此，sf软件包在依赖这种近似方式进行计算时将产生警告。\n\n\n添加其他图层：\n\noz_capitals <- tibble::tribble( \n  ~city,           ~lat,     ~lon,\n  \"Sydney\",    -33.8688, 151.2093,  \n  \"Melbourne\", -37.8136, 144.9631, \n  \"Brisbane\",  -27.4698, 153.0251, \n  \"Adelaide\",  -34.9285, 138.6007, \n  \"Perth\",     -31.9505, 115.8605, \n  \"Hobart\",    -42.8821, 147.3272, \n  \"Canberra\",  -35.2809, 149.1300, \n  \"Darwin\",    -12.4634, 130.8456, \n)\n\nggplot() + \n  geom_sf(data = oz_votes) + \n  geom_sf(data = oz_states, colour = \"black\", fill = NA) + \n  geom_point(data = oz_capitals, mapping = aes(x = lon, y = lat), colour = \"red\") + \n  coord_sf()\n\n\n\n\n\n\n\n\n1.4.2 地图投影\n如果关注地图的准确性，利用经纬度在笛卡尔平面上进行绘制并非最佳办法，至少存在两个基本问题：\n\n地球既不是一个平面，也不是一个完美的球体。关于地球形状的一系列假设被称为大地基准，虽然它对某些数据的可视化可能并不重要，但对其他数据来说，它是至关重要的。有几种不同的选择可以考虑：如果重点是北美，“北美基准”（NAD83）是一个很好的选择；如果视角是全球，“世界大地测量系统”（WGS84）可能更好。\n地图的形状。地球近似椭圆体，但大多数情况下，空间数据需要绘制在一个二维平面上。不可能在不发生扭曲或切割的情况下把椭圆体的表面映射到一个平面上，因此必须对扭曲作出选择。这就是地图投影的工作。 地图投影通常按照它们保留的几何属性来分类，例如：\n\n\n\n面积保护型投影确保地球上面积相等的区域在地图上的绘制面积相等。\n\n形状保护型（保形或保角）投影确保区域的局部形状得到保留。\n\n任何投影都无法做到既保形又保面积，sf允许我们可以指定想使用的地图投影。关于地图投影的更多信息，参见Geocomputation with R。\n综上，大地基准（如WGS84）、地图投影类型（如墨卡托）和投影参数（如原点位置）共同指定了一个坐标参考系统（coordinate reference system，CRS）。这是一套用于将经纬度信息转换为二维地图的完整假设。一个sf对象通常包括一个默认的CRS，如下所示：\n\nst_crs(oz_votes)\n#> Coordinate Reference System:\n#>   User input: EPSG:4283 \n#>   wkt:\n#> GEOGCRS[\"GDA94\",\n#>     DATUM[\"Geocentric Datum of Australia 1994\",\n#>         ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#>             LENGTHUNIT[\"metre\",1]]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"Horizontal component of 3D system.\"],\n#>         AREA[\"Australia including Lord Howe Island, Macquarie Islands, Ashmore and Cartier Islands, Christmas Island, Cocos (Keeling) Islands, Norfolk Island. All onshore and offshore.\"],\n#>         BBOX[-60.56,93.41,-8.47,173.35]],\n#>     ID[\"EPSG\",4283]]\n\n这些输出大多对应于一个众所周知的文本（well-know text，WKT）字符串，它详细描述了CRS。sf内部使用这种冗长的WKT表示法，但是有几种方法可以提供sf理解的用户输入。其中一种方法是以EPSG代码的形式提供数字输入。oz_votes数据中的默认CRS与EPSG代码4283相对应。\n\nst_crs(oz_votes) == st_crs(4283)\n#> [1] TRUE\n\n在ggplot2中，coord_sf()控制CRS，以确保每一层都使用相同的投影。sf数据通常会提供一个合理的CRS选择，coord_sf()默认使用数据geometry列相关的CRS。当需要指定CRS时，可以通过向st_crs()传递crs参数：\n\nggplot(oz_votes) + geom_sf()\nggplot(oz_states) + geom_sf() + coord_sf(crs = st_crs(3112))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.4.3 Raster maps\n绘制地理空间信息的第二种方式是依靠栅格数据（raster data）。与sf数据不同，栅格数据中，地理实体是以一组线、点和多边形的形式来指定的，而栅格则是以图像的形式出现。在最简单的情况下，光栅数据可能是一个有许多不同的图像格式位图文件。具体到地理空间方面，有一些图像格式包括元数据（如大地测量基准、坐标参考系统），可用于将图像信息映射到地球表面。\n在GDAL（地理空间数据抽象库）的帮助下，大多数格式可以很容易地读入R。例如，sf包中的sf::gdal_read()函数提供了从R中访问GDAL的功能。不过，很少需要直接调用这个函数，因为还有其他高级函数可以处理这个问题。\n举个例子，假设我们想绘制澳大利亚气象局（BOM）在其FTP服务器上公开提供的卫星图像。bomrang包(Sparks et al. 2017)提供了一个方便的服务器接口，包括一个返回文件名向量的get_available_imagery()函数和一个下载文件并直接导入R中的get_satellite_imagery()函数。\n这里使用更灵活的方式，可以适用任何FTP服务器，并使用download.file()函数：\n\n# list of all file names with time stamp 2022-08-04 21:00 GMT \n# (BOM images are retained for 24 hours, so this will return an\n# empty vector if you run this code without editing the time stamp)\nfiles <- bomrang::get_available_imagery() %>% \n  str_subset(\"202208042100\")\n\nwalk2(\n  .x = paste0(\"ftp://ftp.bom.gov.au/anon/gen/gms/\", files),\n  .y = file.path(\"raster\", files),\n  .f = ~ download.file(url = .x, destfile = .y)\n)\n\n所有14个文件2都是由日本气象厅运营的Himawari-8地球静止卫星拍摄的图像构建的，并在13个不同的波段拍摄图像。澳大利亚BOM发布的图像包括可见光谱（频道3）和红外光谱（频道13）的数据。\n为了将可见图片导入R，使用stars包(Pebesma 2022)将其导入为stars对象：\n\nimg_vis  <- file.path(\"raster\", \"IDE00422.202208042100.tif\")\nimg_inf <- file.path(\"raster\", \"IDE00421.202208042100.tif\")\n\nlibrary(stars)\n#> Loading required package: abind\nsat_vis <- read_stars(img_vis, RasterIO = list(nBufXSize = 600, nBufYSize = 600))\nsat_inf <- read_stars(img_inf, RasterIO = list(nBufXSize = 600, nBufYSize = 600))\n\nRasterIO参数用来向GDAL传递一列低级参数，使用了nBufXSize和nBufYSize来确保R以低分辨率读取数据（作为600x600像素的图像）。\n\nsat_vis\n#> stars object with 3 dimensions and 1 attribute\n#> attribute(s), summary of first 1e+05 cells:\n#>                            Min. 1st Qu. Median Mean 3rd Qu. Max.\n#> IDE00422.202208042100.tif     0       0      0 37.9      52  255\n#> dimension(s):\n#>      from  to   offset    delta                  refsys point\n#> x       1 600 -5500000  18333.3 Geostationary_Satellite FALSE\n#> y       1 600  5500000 -18333.3 Geostationary_Satellite FALSE\n#> band    1   3       NA       NA                      NA    NA\n#>      values x/y\n#> x      NULL [x]\n#> y      NULL [y]\n#> band   NULL\n\n注意，空间数据也与一个坐标参考系统相关联（在输出中被称为 “refsys”）。\n利用stars包提供的geom_stars()函数，可以使用ggplot2进行绘图：\n\nggplot() +\n  geom_stars(data = sat_vis) +\n  coord_equal()\n\n\n\n\n\n\n\ngeom_stars()函数要求数据是stars对象，并将栅格数据映射到填充（fill）美学。因此，上面的卫星图像中的蓝色阴影是由ggplot2的比例决定的，而不是图像本身。也就是说，尽管sat_vis包含三个波段，但上面的绘图只显示第一个波段，原始数据值（范围从0到255）被映射到ggplot2用于连续数据的默认蓝色调色板上。为了看到图像文件的真实面貌，我们可以用facet_wrap()分离这些波段：\n\nggplot() +\n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  facet_wrap(vars(band)) +\n  coord_equal() +\n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n只显示原始图像不易弄清楚相关的陆地在哪里，我们可能希望将卫星数据与oz_states矢量地图重叠，以显示澳大利亚政治实体的轮廓。这样做需注意，这两个数据源具有不同的坐标参考系统。为了正确投影oz_states的数据，需使用sf包中的st_transform()函数对数据进行转换。下面的代码将从sat_vis栅格对象中提取CRS，并应用于oz_states，而后进行可视化：\n\noz_states <- st_transform(oz_states, crs = st_crs(sat_vis))\n\nggplot() +\n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  geom_sf(data = oz_states, fill = NA, color = \"white\") +\n  coord_sf() +\n  theme_void() +\n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n可以看到在这个拍摄时间，澳大利亚即将日出。\n如何在上面绘制更多的常规数据呢？一个简单的例子是根据包含经纬度的oz_capitals数据框来绘制澳大利亚首都的位置。然而，由于这些数据没有与CRS相关联，并且与sat_vis中的栅格数据的比例不一样，所以这些数据也需要进行转换。为此，首先需要使用st_as_sf()从oz_capitals数据中创建sf对象：\n\ncities <- oz_capitals %>% \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326, remove = FALSE)\n\n这个投影是使用EPSG代码4326设置的，这是使用经纬度值作为坐标并依靠WGS84基准的椭圆形投影。而后可以将经纬度几何坐标转换为与sat_vis数据的几何形状相匹配。\n\ncities <- st_transform(cities, st_crs(sat_vis))\n\nggplot() +\n  geom_stars(data = sat_vis, show.legend = FALSE) +\n  geom_sf(data = oz_states, fill = NA, color = \"white\") +\n  geom_sf(data = cities, color = \"red\") +\n  coord_sf() +\n  theme_void() +\n  scale_fill_gradient(low = \"black\", high = \"white\")\n\n\n\n\n\n\n\n如果有自己的形状文件（.shp），可以用sf::read_sf()把它们加载到R中。"
  },
  {
    "objectID": "vis-ggplot2-layers.html#网络图",
    "href": "vis-ggplot2-layers.html#网络图",
    "title": "1  ggplot2-layers",
    "section": "\n1.5 网络图",
    "text": "1.5 网络图\n网络在可视化中占据了一席之地，和地图、空间数据一样，网络具有特定的数据结构和可视化范式，ggplot2并不直接支持网络图，接下来将使用ggraph包(Pedersen 2021b)进行网络的可视化。\n\n1.5.1 网络数据\n网络数据可以编码为两个相互关联的数据帧，分别编码节点和边，这就是tidygraph包(Pedersen 2022)使用的方法，它是ggraph的基础数据处理包。\n\nlibrary(tidygraph)\nlibrary(ggraph)\n\ngraph <- play_erdos_renyi(n = 10, p = .2) %>% \n  activate(nodes) %>% \n  mutate(class = sample(letters[1:4], n(), replace = TRUE)) %>% \n  activate(edges) %>% \n  arrange(.N()$class[from])\ngraph\n#> # A tbl_graph: 10 nodes and 12 edges\n#> #\n#> # A directed simple graph with 1 component\n#> #\n#> # Edge Data: 12 × 2 (active)\n#>    from    to\n#>   <int> <int>\n#> 1     2     9\n#> 2     1     2\n#> 3     6     3\n#> 4     7     5\n#> 5     6    10\n#> 6     5     7\n#> # … with 6 more rows\n#> #\n#> # Node Data: 10 × 1\n#>   class\n#>   <chr>\n#> 1 c    \n#> 2 b    \n#> 3 d    \n#> # … with 7 more rows\n\n一些新函数：activate()指定在网络的哪个部分工作（节点或者边）；即使在处理边的时候，.N()也可以访问当前图形的节点数据（与之对应的.E()函数访问边的数据，以及.G()访问整个图形）。\ntidygraph包的as_tbl_graph()可以将大部分不同形式的网络数据进行转换:\n\nhead(highschool)\n#>   from to year\n#> 1    1 14 1957\n#> 2    1 15 1957\n#> 3    1 21 1957\n#> 4    1 54 1957\n#> 5    1 55 1957\n#> 6    2 21 1957\n\nhs_graph <- as_tbl_graph(highschool, directed = FALSE) # 不带方向\nhs_graph\n#> # A tbl_graph: 70 nodes and 506 edges\n#> #\n#> # An undirected multigraph with 1 component\n#> #\n#> # Node Data: 70 × 1 (active)\n#>   name \n#>   <chr>\n#> 1 1    \n#> 2 2    \n#> 3 3    \n#> 4 4    \n#> 5 5    \n#> 6 6    \n#> # … with 64 more rows\n#> #\n#> # Edge Data: 506 × 3\n#>    from    to  year\n#>   <int> <int> <dbl>\n#> 1     1    13  1957\n#> 2     1    14  1957\n#> 3     1    20  1957\n#> # … with 503 more rows\n\n\nluv_clust <- hclust(dist(luv_colours[, 1:3]))\nluv_graph <- as_tbl_graph(luv_clust)\nluv_graph\n#> # A tbl_graph: 1313 nodes and 1312 edges\n#> #\n#> # A rooted tree\n#> #\n#> # Node Data: 1,313 × 4 (active)\n#>   height leaf  label members\n#>    <dbl> <lgl> <chr>   <int>\n#> 1     0  TRUE  \"101\"       1\n#> 2     0  TRUE  \"427\"       1\n#> 3   778. FALSE \"\"          2\n#> 4     0  TRUE  \"571\"       1\n#> 5     0  TRUE  \"426\"       1\n#> 6     0  TRUE  \"424\"       1\n#> # … with 1,307 more rows\n#> #\n#> # Edge Data: 1,312 × 2\n#>    from    to\n#>   <int> <int>\n#> 1     3     1\n#> 2     3     2\n#> 3     8     6\n#> # … with 1,309 more rows\n\n我们可以看到，tidygraph在转换时自动添加了额外的信息，例如，highschool数据中的year列，以及分层聚类luv_clust中的label和leaf节点。\n\n# 中心度计算\ngraph %>% \n  activate(nodes) %>% \n  mutate(centrality = centrality_pagerank()) %>% \n  arrange(desc(centrality))\n#> # A tbl_graph: 10 nodes and 12 edges\n#> #\n#> # A directed simple graph with 1 component\n#> #\n#> # Node Data: 10 × 2 (active)\n#>   class centrality\n#>   <chr>      <dbl>\n#> 1 c         0.201 \n#> 2 c         0.191 \n#> 3 c         0.120 \n#> 4 c         0.120 \n#> 5 d         0.0920\n#> 6 a         0.0778\n#> # … with 4 more rows\n#> #\n#> # Edge Data: 12 × 2\n#>    from    to\n#>   <int> <int>\n#> 1     7     1\n#> 2     9     7\n#> 3    10     8\n#> # … with 9 more rows\n\ntidygraph支持一系列丰富的算法，比如中心度计算（哪个节点最中心）、排序（对节点进行排序，使节点位于与之相连的节点附近）、分组（在网络内寻找群组）等，具体见这里。\n网络图更关注拓扑结构而不是两个变量之间的关系，我们采用布局（Layouts）的概念来显示网络拓扑结构。布局是利用网络结构来计算每个节点的x和y值（通常是任意的）的算法，最终用于可视化。换句话说，在绘制表格数据时，x和y的美学几乎总是被数据中的现有变量（或现有数据的统计转换）映射，而在绘制网络数据时，x和y被来自网络拓扑结构的值映射，这些值本身没有意义。\n\nggraph(hs_graph) +\n  geom_edge_link() +\n  geom_node_point()\n#> Using `stress` as default layout\n\nggraph(hs_graph, layout = \"drl\") +\n  geom_edge_link() +\n  geom_node_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhs_graph <- hs_graph %>% \n  activate(edges) %>% \n  mutate(edge_weights = runif(n()))\nggraph(hs_graph, layout = \"stress\", weights = edge_weights) +\n  geom_edge_link(aes(alpha = edge_weights)) +\n  geom_node_point() +\n  scale_edge_alpha_identity()\n\n# 环形\nggraph(luv_graph, layout = \"dendrogram\", circular = TRUE) +\n  geom_edge_link() +\n  coord_fixed()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.5.2 绘制节点（nodes）\n\n# 只显示2个以上的节点，按中心度着色\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point(\n    aes(filter = centrality_degree() > 2,\n        color = centrality_power()),\n    size = 2\n  )\n\n# 树状图\nggraph(luv_graph, layout = \"treemap\") +\n  geom_node_tile(aes(fill = depth))\n#> Warning: Existing variables `height`, `leaf` overwritten by layout\n#> variables\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.5.3 绘制边缘（edges）\n\nggraph(graph, layout = \"stress\") +\n  geom_edge_link(aes(alpha = after_stat(index)))\n\nggraph(graph, layout = \"stress\") +\n  geom_edge_link2(\n    aes(color = node.class),\n    width = 3, lineend = \"round\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_fan()\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_parallel()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggraph(luv_graph, layout = \"dendrogram\", height = height) +\n  geom_edge_elbow()\n\nggraph(luv_graph, layout = \"dendrogram\", height = height) +\n  geom_edge_bend()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 节点会遮盖箭头\nggraph(graph, layout = \"stress\") +\n  geom_edge_link(arrow = arrow()) +\n  geom_node_point(aes(color = class), size = 6)\n\n# 解决上述问题\nggraph(graph, layout = \"stress\") +\n  geom_edge_link(\n    arrow = arrow(),\n    start_cap = circle(3, \"mm\"),\n    end_cap = circle(3, \"mm\")\n  ) +\n  geom_node_point(aes(color = class), size = 6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.5.4 分面\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_edges(~year)\n\n\n\n\n\n\n\n\nggraph(hs_graph, layout = \"stress\") +\n  geom_edge_link() +\n  geom_node_point() +\n  facet_nodes(~ group_spinglass())"
  },
  {
    "objectID": "vis-ggplot2-layers.html#注释",
    "href": "vis-ggplot2-layers.html#注释",
    "title": "1  ggplot2-layers",
    "section": "\n1.6 注释",
    "text": "1.6 注释\n从概念上讲，注释为绘图提供了元数据，它提供了关于数据的额外信息。\n\n1.6.1 图形和轴标题\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = factor(cyl))) +\n  labs(\n    x = \"Engine displacement (litres)\",\n    y = \"Highway miles per gallon\",\n    color = \"Number of cylinders\",\n    title = \"Mileage by engine size and cylinders\",\n    subtitle = \"Source: http://fueleconomy.gov\"\n  )\n\n\n\n\n\n\n\n通常给labs()提供文本字符串，并用\\n指定换行，也可以提供用quote()包裹的数学表达式：\n\nvalues <- seq(from = -2, to = 2, by = .01)\ndf <- data.frame(x = values, y = values ^ 3)\nggplot(df, aes(x, y)) +\n  geom_line() +\n  labs(y = quote(f(x) == x^3))\n\n\n\n\n\n\n\n在ggtext包(Wilke 2020)和ggplot2主题系统下，可以使用Markdown语法进行标记：\n\ndf <- data.frame(x = 1:3, y = 1:3)\nbase <- ggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(x = \"Axis title with *italics* and **boldface**\")\n\nbase\nbase + theme(axis.title.x = ggtext::element_markdown())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n未出现斜体和加粗效果，暂未发现原因。日后会处理。\n\n\n\n1.6.2 文本标签\n字体\n\ndf <- data.frame(x = 1, y = 3:1, family = c(\"sans\", \"serif\", \"mono\"))\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = family, family = family))\n\n\n\n\n\n\n\n如需更多字体，使用showtext包(Qiu and details. 2022)：\n\nlibrary(showtext)\n#> Loading required package: sysfonts\n#> Loading required package: showtextdb\n\n# font_install(source_han_serif()) # 安装字体库\nfont_families()\n#> [1] \"sans\"                \"serif\"              \n#> [3] \"mono\"                \"wqy-microhei\"       \n#> [5] \"source-han-serif-cn\"\nhead(font_files()) # 查看系统字体\n#>               path         file       family        face\n#> 1 C:/Windows/Fonts  AGENCYB.TTF    Agency FB        Bold\n#> 2 C:/Windows/Fonts  AGENCYR.TTF    Agency FB     Regular\n#> 3 C:/Windows/Fonts    ALGER.TTF     Algerian     Regular\n#> 4 C:/Windows/Fonts  ANTQUAB.TTF Book Antiqua        Bold\n#> 5 C:/Windows/Fonts ANTQUABI.TTF Book Antiqua Bold Italic\n#> 6 C:/Windows/Fonts  ANTQUAI.TTF Book Antiqua      Italic\n#>        version                ps_name\n#> 1 Version 1.01          AgencyFB-Bold\n#> 2 Version 1.01           AgencyFB-Reg\n#> 3 Version 1.57               Algerian\n#> 4 Version 2.35       BookAntiqua-Bold\n#> 5 Version 2.35 BookAntiqua-BoldItalic\n#> 6 Version 2.35     BookAntiqua-Italic\n\n\nshowtext_auto()\n\nfont_add(\"simkai\", \"simkai.ttf\")\nfont_add(\"constan\", \"constan.ttf\", italic = \"constani.ttf\")\n\nggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +\n    theme(axis.title = element_blank(), axis.ticks = element_blank(),\n          axis.text = element_blank()) +\n    annotate(\"text\", 1, 1.1, family = \"simkai\", size = 15,\n             label = \"你好，世界！\") +\n    annotate(\"text\", 1, 0.9, label = 'Chinese for \"Hello, world!\"',\n             family = \"constan\", fontface = \"italic\", size = 8)\n\n\n\n\n\n\n\n加粗、斜体\n\ndf <- data.frame(x = 1, y = 3:1, face = c(\"plain\", \"bold\", \"italic\"))\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = face, fontface = face))\n\n\n\n\n\n\n\n对齐方式\n\ndf <- data.frame(\n  x = c(1, 1, 2, 2, 1.5),\n  y = c(1, 2, 1, 2, 1.5),\n  text = c(\n    \"bottom-left\", \"top-left\",\n    \"bottom-right\", \"top-right\", \"center\"\n  )\n)\n\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text))\nggplot(df, aes(x, y)) +\n  geom_text(aes(label = text), vjust = \"inward\", hjust = \"inward\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n微调\n\ndf <- data.frame(resp = c(1.2, 3.4, 2.5), trt = letters[1:3])\n\nggplot(df, aes(resp, trt)) +\n  geom_point() +\n  geom_text(aes(label = paste0(\"(\", resp, \")\"))) +\n  xlim(1, 3.6)\nggplot(df, aes(resp, trt)) +\n  geom_point() +\n  geom_text(aes(label = paste0(\"(\", resp, \")\")), nudge_y = -.25) +\n  xlim(1, 3.6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n重叠检查\n按照标签在数据框中出现的先后顺序绘制标签。如后来的标签覆盖已绘制的标签，则忽略后来的标签。实际使用中，可以对标签进行优先级排序，后绘制带有标签的图，以强调重要的数据。\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_text(aes(label = model)) +\n  xlim(1, 8)\nggplot(mpg, aes(displ, hwy)) +\n  geom_text(aes(label = model), check_overlap = TRUE) +\n  xlim(1, 8)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n另一种方法是利用ggrepel包(Slowikowski 2021)的geom_text_repel()函数进行绘制：\n\nmini_mpg <- mpg[sample(nrow(mpg), 20), ]\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(color = \"red\") +\n  ggrepel::geom_text_repel(data = mini_mpg, aes(label = class))\n#> Warning: ggrepel: 1 unlabeled data points (too many overlaps).\n#> Consider increasing max.overlaps\n\n\n\n\n\n\n\nggfittext包(Wilkins 2021)可以确保文本标签适应其放置的空间：\n\nlibrary(ggfittext)\nggplot(animals, aes(type, flies, label = animal)) +\n  geom_tile(fill = \"white\", color = \"black\") +\n  geom_fit_text()\nggplot(animals, aes(type, flies, label = animal)) +\n  geom_tile(fill = \"white\", color = \"black\") +\n  geom_fit_text(reflow = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.6.3 自定义注释\n\nggplot(economics, aes(date, unemploy)) +\n  geom_line()\n\n# 美国总统任期和党派\npresidential <- subset(presidential, start > economics$date[1])\nggplot(economics) +\n  geom_rect(data = presidential,\n            aes(xmin = start, xmax = end, fill = party),\n            ymin = -Inf, ymax = Inf, alpha = .2) +\n  geom_vline(data = presidential,\n             aes(xintercept = as.numeric(start)),\n             color = \"grey50\", alpha = .5) +\n  geom_text(data = presidential,\n            aes(start, y = 2500, label = name),\n            size = 3, vjust = 0, hjust = 0, nudge_x = 50) +\n  geom_line(aes(date, unemploy)) +\n  scale_fill_manual(values = c(\"blue\", \"red\")) +\n  labs(x = \"date\", y = \"unemployment\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np <- ggplot(mpg, aes(displ, hwy)) +\n  geom_point(data = filter(mpg, manufacturer == \"subaru\"),\n             color = \"orange\", size = 3) +\n  geom_point()\n\np + \n  annotate(\"point\", x = 5.5, y = 40, color = \"orange\", size = 3) +\n  annotate(\"point\", x = 5.5, y = 40) +\n  annotate(\"text\", x = 5.6, y = 40, label = \"subaru\", hjust = \"left\")\n\n# 更好的方法\np +\n  annotate(\"curve\", x = 4, y = 35, xend = 2.65, yend = 27,\n           curvature = .3, arrow = arrow(length = unit(2, \"mm\"))) +\n  annotate(\"text\", x = 4.1, y = 35, label = \"subaru\", hjust = \"left\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.6.4 直接标注\ndirectlabels包(Hocking 2021)：\n\nggplot(mpg, aes(displ, hwy, color = class)) +\n  geom_point()\n\nggplot(mpg, aes(displ, hwy, color = class)) +\n  geom_point(show.legend = FALSE) +\n  directlabels::geom_dl(aes(label = class), method = \"smart.grid\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggforce包(Pedersen 2021a):\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  ggforce::geom_mark_ellipse(aes(label = cyl, group = cyl))\n\n\n\n\n\n\n\ngghighlight包(Yutani 2022)：\n\ndata(Oxboys, package = \"nlme\")\nggplot(Oxboys, aes(age, height, group = Subject)) +\n  geom_line() +\n  geom_point() +\n  gghighlight::gghighlight(Subject %in% 1:3)\n\n\n\n\n\n\n\n分面注释：\n\nggplot(mpg, aes(displ, hwy, color = factor(cyl))) +\n  geom_point() +\n  gghighlight::gghighlight() +\n  facet_wrap(vars(cyl))"
  },
  {
    "objectID": "vis-ggplot2-layers.html#图形排列",
    "href": "vis-ggplot2-layers.html#图形排列",
    "title": "1  ggplot2-layers",
    "section": "\n1.7 图形排列",
    "text": "1.7 图形排列\nggplot2的语法是关于创建单个图形的，虽然分面系统提供了产生多个子图的方法，但都属于同一个可视化的部分，它们共享图层、数据和标度。我们经常需要将多幅独立创建的图形组合为一张图，许多包已应运而生，这里重点介绍patchwork包(Pedersen 2020)。\n绘制四幅图形用于排列：\n\np1 <- ggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy))\n\np2 <- ggplot(mpg) + \n  geom_bar(aes(x = as.character(year), fill = drv), position = \"dodge\") + \n  labs(x = \"year\")\n\np3 <- ggplot(mpg) + \n  geom_density(aes(x = hwy, fill = drv), colour = NA) + \n  facet_grid(rows = vars(drv))\n\np4 <- ggplot(mpg) + \n  stat_summary(aes(x = drv, y = hwy, fill = drv), geom = \"col\", fun.data = mean_se) +\n  stat_summary(aes(x = drv, y = hwy), geom = \"errorbar\", fun.data = mean_se, width = 0.5)\n\n\nlibrary(patchwork)\n\np1 + p2\n\n\n\n\n\n\n\n+并未指定任何具体的布局，只是将图形显示在一起。在没有布局的情况下，facet_wrap()中管理行和列的算法将用于决定行数和列数。如果我们添加3幅图形，则会创建1×3的网格；添加4幅图形，则会创建2×2的网格。\n\np1 + p2 + p3 + p4\n\n\n\n\n\n\n\n可以看出，patchwork关注绘图区域的对齐。\n\n1.7.1 布局控制\n\np1 + p2 + p3 + plot_layout(ncol = 2)\n\n\n\n\n\n\n\n/设置列数为1，|设置行数为1：\n\n# 两幅图排为1列\np1 / p2\n\n\n\n\n\n\n\n\n# 两幅图排为1行\np3 | p4\n\n\n\n\n\n\n\n/和|可以进行组合以创建更加复杂的图形排列：\n\np3 | (p2 / (p1 | p4))\n\n\n\n\n\n\n\n针对特别复杂的布局，可以在plot_layout()的design参数中制定文本形式的非表格布局：\n\nlayout <- \"\nAAB\nC#B\nCDD\n\"\nlayout\n#> [1] \"\\nAAB\\nC#B\\nCDD\\n\"\n\np1 + p2 + p3 + p4 + plot_layout(design = layout)\n\n\n\n\n\n\n\n从上可以看出，图形间的图例经常有多余，patchwork提供了简便的处理方法，可以删除完全一样的图例：\n\np1 + p2 + p3 + plot_layout(ncol = 2, guides = \"collect\")\n\n\n\n\n\n\n\n可以指定绘图区域，优化空间使用：\n\np1 + p2 + p3 + guide_area() + plot_layout(ncol = 2, guides = \"collect\")\n\n\n\n\n\n\n\n\n1.7.2 修改子图\n在patchwork渲染前，所有子图仍为ggplot对象，因此在组合起来后可以被修改，使用[[]]索引后进行调整：\n\np12 <- p1 + p2\np12[[2]] <- p12[[2]] + theme_light()\np12\n\n\n\n\n\n\n\n使用&一次性修改所有子图：\n\np1 + p4 & theme_minimal()\n\n\n\n\n\n\n\n如果图形在轴上具有相同的映射，可以用这种方法指定共同轴：\n\np1 + p4 & scale_y_continuous(limits = c(0, 45))\n\n\n\n\n\n\n\n\n1.7.3 添加注释\n一旦图形组合完毕，它们就成为一个整体，可以通过plot_annotation()向整体添加标题、副标题等注释。\n\np34 <- p3 + p4 + plot_annotation(\n  title = \"A closer look at the effect of drive train in cars\",\n  caption = \"Source: mpg dataset in ggplot2\"\n)\np34\n\n\n\n\n\n\n\n\np34 + plot_annotation(theme = theme_gray(base_family = \"mono\"))\n\n\n\n\n\n\n\n为子图添加标签在科学文献中尤其常用，ggplot2带有tag元素，patchwork提供tag_levels参数进行自动设置：\n\np123 <- p1 | (p2 / p3)\np123 + plot_annotation(tag_levels = \"I\") # 使用大写罗马数字\n\n\n\n\n\n\n\n使用嵌套定义新的标签级别：\n\np123[[2]] <- p123[[2]] + plot_layout(tag_level = \"new\")\np123 + plot_annotation(tag_levels = c(\"I\", \"a\"))\n\n\n\n\n\n\n\n\n1.7.4 图形叠加\npatchwork提供了inset_element()函数用于在给定的区域上放置图形：\n\np1 + inset_element(p2, left = .5, bottom = .4, right = .9, top = .95)\n\n\n\n\n\n\n\n\np24 <- p2 / p4 + plot_layout(guides = \"collect\")\np1 + inset_element(p24, left = .5, right = .9, bottom = .05, top = .9)\n\n\n\n\n\n\n\n\np12 <- p1 + inset_element(p2, left = .5, right = .9, bottom = .5, top = .95)\np12 & theme_bw()\n\n\n\n\n\n\n\n\np12 + plot_annotation(tag_levels = \"A\")\n\n\n\n\n\n\n\n更多patchwork的功能，可以查看它的网站：https://patchwork.data-imaginist.com/。\n\n\n\n\nHocking, Toby Dylan. 2021. “Directlabels: Direct Labels for Multicolor Plots.” https://CRAN.R-project.org/package=directlabels.\n\n\nPebesma, Edzer. 2018. “Simple Features for r: Standardized Support for Spatial Vector Data” 10. https://doi.org/10.32614/RJ-2018-009.\n\n\n———. 2022. “Stars: Spatiotemporal Arrays, Raster and Vector Data Cubes.” https://CRAN.R-project.org/package=stars.\n\n\nPedersen, Thomas Lin. 2020. “Patchwork: The Composer of Plots.” https://CRAN.R-project.org/package=patchwork.\n\n\n———. 2021a. “Ggforce: Accelerating ’Ggplot2’.” https://CRAN.R-project.org/package=ggforce.\n\n\n———. 2021b. “Ggraph: An Implementation of Grammar of Graphics for Graphs and Networks.” https://CRAN.R-project.org/package=ggraph.\n\n\n———. 2022. “Tidygraph: A Tidy API for Graph Manipulation.” https://CRAN.R-project.org/package=tidygraph.\n\n\nQiu, Yixuan, and authors/contributors of the included software. See file AUTHORS for details. 2022. “Showtext: Using Fonts More Easily in r Graphs.” https://CRAN.R-project.org/package=showtext.\n\n\nSlowikowski, Kamil. 2021. “Ggrepel: Automatically Position Non-Overlapping Text Labels with ’Ggplot2’.” https://CRAN.R-project.org/package=ggrepel.\n\n\nSparks, Adam H, Mark Padgham, Hugh Parsonage, and Keith Pembleton. 2017. “Bomrang: Fetch Australian Government Bureau of Meteorology Weather Data” 2. https://doi.org/10.21105/joss.00411.\n\n\nTeucher, Andy, and Kenton Russell. 2022. “Rmapshaper: Client for ’Mapshaper’ for ’Geospatial’ Operations.” https://CRAN.R-project.org/package=rmapshaper.\n\n\nWilke, Claus O. 2020. “Ggtext: Improved Text Rendering Support for ’Ggplot2’.” https://CRAN.R-project.org/package=ggtext.\n\n\nWilkins, David. 2021. “Ggfittext: Fit Text Inside a Box in ’Ggplot2’.” https://CRAN.R-project.org/package=ggfittext.\n\n\nYutani, Hiroaki. 2022. “Gghighlight: Highlight Lines and Points in ’Ggplot2’.” https://CRAN.R-project.org/package=gghighlight."
  },
  {
    "objectID": "vis-ggplot2-scales.html",
    "href": "vis-ggplot2-scales.html",
    "title": "2  ggplot2-scales",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节正在进行写作和结构调整，可能出现混乱或不完整的情况。\n标度控制数据到美学的映射，它将数据转为大小（size）、颜色（color）、位置（position）或形状（shape），它也提供了解释绘图的工具：坐标轴和图例。"
  },
  {
    "objectID": "vis-ggplot2-scales.html#位置标度和坐标轴",
    "href": "vis-ggplot2-scales.html#位置标度和坐标轴",
    "title": "2  ggplot2-scales",
    "section": "\n2.1 位置标度和坐标轴",
    "text": "2.1 位置标度和坐标轴\n\n2.1.1 数值型\nLimits\nlims()或limits参数可用于修改坐标轴范围，需要接受长度为2的数值型向量。如果只设置单侧范围，另一侧设置为NA。\n\nmpg %>% filter(year == 1999) %>% \n  ggplot(aes(displ, hwy)) +\n  geom_point() +\n  scale_x_continuous(limits = c(1, 7)) +\n  scale_y_continuous(limits = c(10, 45))\n\nmpg %>% filter(year == 2008) %>% \n  ggplot(aes(displ, hwy)) +\n  geom_point() +\n  lims(x = c(1, 7), y = c(10, 45))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZooming in\n如果目标是放大绘图的一部分，使用coord_cartesian()的xlim和ylim参数通常会更好。\n\nbase <- ggplot(mpg, aes(drv, hwy)) +\n  geom_hline(yintercept = 28, color = \"red\") +\n  geom_boxplot()\n\nbase\nbase + coord_cartesian(ylim = c(10, 35))\nbase + ylim(10, 35)\n#> Warning: Removed 6 rows containing non-finite values (stat_boxplot).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVisual range expansion\n\nbase <- ggplot(faithfuld, aes(waiting, eruptions)) +\n  geom_raster(aes(fill = density)) +\n  theme(legend.position = \"none\") +\n  labs(x = NULL, y = NULL)\n\nbase\nbase + \n  scale_x_continuous(expand = expansion(0)) +\n  scale_y_continuous(expand = expansion(0))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbase + \n  scale_x_continuous(expand = expansion(add = 3)) +\n  scale_y_continuous(expand = expansion(add = 3))\n\nbase +\n  scale_x_continuous(expand = expansion(mult = .2)) +\n  scale_y_continuous(expand = expansion(mult = .2))\n\nbase +\n  scale_x_continuous(expand = expansion(mult = c(.05, .2))) +\n  scale_y_continuous(expand = c(.05, 0, .2, 0))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nadd参数是在与数据变量相同的尺度上指定的，mult参数是相对于轴的范围指定的。\nBreaks"
  },
  {
    "objectID": "vis-ggplot2-grammar.html",
    "href": "vis-ggplot2-grammar.html",
    "title": "3  ggplot2-grammar",
    "section": "",
    "text": "library(ggplot2)"
  },
  {
    "objectID": "Shiny.html",
    "href": "Shiny.html",
    "title": "Shiny",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "shiny1.html",
    "href": "shiny1.html",
    "title": "\n4  Shiny\n",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "Finance.html",
    "href": "Finance.html",
    "title": "Finance",
    "section": "",
    "text": "各位看客：\n\n\n\nLearn-R 仍在写作流程中。本章节目前为初步构想，不建议阅读。"
  },
  {
    "objectID": "fin-tidy.html",
    "href": "fin-tidy.html",
    "title": "\n5  Tidy Finance with R\n",
    "section": "",
    "text": "原先的笔记在这里，会迁移过来。"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Coene, John. 2022. “Echarts4r: Create Interactive Graphs with\n’Echarts JavaScript’ Version 5.” https://CRAN.R-project.org/package=echarts4r.\n\n\nHocking, Toby Dylan. 2021. “Directlabels: Direct Labels for\nMulticolor Plots.” https://CRAN.R-project.org/package=directlabels.\n\n\nPebesma, Edzer. 2018. “Simple Features for r:\nStandardized Support for Spatial Vector Data” 10. https://doi.org/10.32614/RJ-2018-009.\n\n\n———. 2022. “Stars: Spatiotemporal Arrays, Raster and Vector Data\nCubes.” https://CRAN.R-project.org/package=stars.\n\n\nPedersen, Thomas Lin. 2020. “Patchwork: The Composer of\nPlots.” https://CRAN.R-project.org/package=patchwork.\n\n\n———. 2021a. “Ggforce: Accelerating ’Ggplot2’.” https://CRAN.R-project.org/package=ggforce.\n\n\n———. 2021b. “Ggraph: An Implementation of Grammar of Graphics for\nGraphs and Networks.” https://CRAN.R-project.org/package=ggraph.\n\n\n———. 2022. “Tidygraph: A Tidy API for Graph Manipulation.”\nhttps://CRAN.R-project.org/package=tidygraph.\n\n\nQiu, Yixuan, and authors/contributors of the included software. See file\nAUTHORS for details. 2022. “Showtext: Using Fonts More Easily in r\nGraphs.” https://CRAN.R-project.org/package=showtext.\n\n\nSlowikowski, Kamil. 2021. “Ggrepel: Automatically Position\nNon-Overlapping Text Labels with ’Ggplot2’.” https://CRAN.R-project.org/package=ggrepel.\n\n\nSparks, Adam H, Mark Padgham, Hugh Parsonage, and Keith Pembleton. 2017.\n“Bomrang: Fetch Australian Government\nBureau of Meteorology Weather Data” 2. https://doi.org/10.21105/joss.00411.\n\n\nTeucher, Andy, and Kenton Russell. 2022. “Rmapshaper: Client for\n’Mapshaper’ for ’Geospatial’ Operations.” https://CRAN.R-project.org/package=rmapshaper.\n\n\nWickham, Hadley. 2016. “Ggplot2: Elegant Graphics for Data\nAnalysis.” https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for Data\nScience. O’Reilly Media.\n\n\nWilke, Claus O. 2020. “Ggtext: Improved Text Rendering Support for\n’Ggplot2’.” https://CRAN.R-project.org/package=ggtext.\n\n\nWilkins, David. 2021. “Ggfittext: Fit Text Inside a Box in\n’Ggplot2’.” https://CRAN.R-project.org/package=ggfittext.\n\n\nYutani, Hiroaki. 2022. “Gghighlight: Highlight Lines and Points in\n’Ggplot2’.” https://CRAN.R-project.org/package=gghighlight."
  }
]